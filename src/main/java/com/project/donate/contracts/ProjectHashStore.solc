pragma solidity ^0.5.3; 

contract ProjectHashStore {
    
    struct Project {
        bytes32 id; 
        bytes32 projectHash; 
        uint updateTime;
        uint openedTime; 
    }
    
    mapping (address => uint[]) public projectIndicesStorage; 
    
    Project[] public projects; 
    
    function registerProject(bytes32 _id, bytes32 _projectHash) public {
        
        Project memory newProject = Project(_id, _projectHash, now, 0);
        
        uint newProjectInd = projects.length; 
        projects.push(newProject);
        projectIndicesStorage[msg.sender].push(newProjectInd); 
    }
    
    function updateProject (bytes32 _projectId, bytes32 _newHash) public returns (bool ifUpdated) {
        
        int projectIndex = getProject(msg.sender, _projectId);
        
        if (projectIndex < 0) {
            return false; 
        } 
        
        Project storage updatedProject = projects[uint(projectIndex)]; 
        updatedProject.projectHash = _newHash; 
        updatedProject.updateTime = now; 
        
        return true; 
    }
    
    function getProject (address _owner, bytes32 _projectId) internal view returns (int index) {
        
        uint[] memory listOfProjectInd = projectIndicesStorage[_owner]; 
        uint len = listOfProjectInd.length;
        
        for (uint i = 0; i < len; i++ ) {
            if (projects[listOfProjectInd[i]].id == _projectId) {
                return int(listOfProjectInd[i]);
            }
        }
        return -1; 
    }
    
    function openProject(bytes32 _projectId) public returns (bool){
        
        int projectIndex = getProject(msg.sender, _projectId);
        
        if (projectIndex < 0) {
            return false; 
        } 
        
        Project storage updatedProject = projects[uint(projectIndex)]; 
        updatedProject.openedTime = now; 
        
        return true; 
    }
    
    function getProjectFromList(bytes32 _projectId) internal view returns (int) {
        uint len = projects.length;
        
        for (uint i = 0; i < len; i++ ) {
            if (projects[i].id == _projectId) {
                return int(i);
            }
        }
        
        return -1; 
    }
    
    function isNotChange(bytes32 _projectId, bytes32 _projectHash) public view returns (bool){
        
        int projectIndex = getProjectFromList(_projectId);
        
        if (projectIndex < 0) {
            return false; 
        } 
        
        Project memory updatedProject = projects[uint(projectIndex)]; 
        return (updatedProject.updateTime < updatedProject.openedTime) && (updatedProject.projectHash == _projectHash);
    }
    
}